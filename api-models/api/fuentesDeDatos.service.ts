/**
 * Api CRM
 * Especificaciónes de la API pública de CRM.  # Versión 2 parte pública.  ***  Los métodos estaran protegidos mediante el paso de un token válido.  Los métodos que puedan ser accedidos por aplicaciones de terceros estarán protegidos por el paso de una api key que tendrá definidos los permisos correspondientes.  Se eliminan las descriciones de cambios de versiones anteriores a la 5, se pueden consultar en las versiones previas    ### 0.5.0 ***  ### Contacto Campaña Se define el esquema CampaignContact Se añaden los métodos para la obtención, creación y borrado masivo de contactos en una campaña Se añaden los métodos para la obtención, edición y borrado de contactos , de manera individual, en una campaña  ### CitizenCard Se añade la propiedad citizenId en tarjeta ciudadana   ### 0.5.1 *** Se declara el esquema Survey que almacenará valoraciones del ciudadano  ### Solicitudes Se depreca   /crmrequests/{crmRequestId}/bpsprocess Añade el método POST   /crmrequests/{crmRequestId}/survey para almacenar la respuesta a la valoración de la solicitud Se añade la propiedad survey a la solicitud para almacenar la valoración del ciudadano a la atención recibida Se modifica el método en el método /crmrequests/{crmRequestId}/situation la clase del objeto a enviar en el post de CrmRequest a Situation  ### Person Se añade la propiedad surveys para almacenar las valoraciones del ciudadano al servicio prestado por el ayuntamiento Añade el método POST   /persons/survey para almacenar una nueva respuesta de encuesta de valoración del servicio  ### 0.5.2 ***  ### Personas   se modifica el método /persons/survey/ a   /persons/survey/{personId} pasando el id de la persona a la que establecer la encuesta    ## 0.5.3 ***  ### Auth Se define el método auth/thirdpartylogin para proporcionar login SSO a terceros (ya implementado)  ### Comment Se agregan los campos tipo, codigo y descripcion de la situacion a los comentarios de una solicitud y una interaccion  ## 0.5.4 ***  ### Tipos de interacciones  Define la propiedad identificator en el esquema de tipo de interacción Define el método  /interactions/types/{identificator} para obtener un tipo de interacción por su identificador  ## 0.5.5 ***  ### Personas Se añade el atributo que contiene la lista negra de tipos de interacciones a no registrar en la persona  ### CensusType Se añade el atributo email que guarda el email del usuario en el censo   ## 0.5.6  Corrige la respuesta de método  /interactions/types/{identificator} no es un array 
 *
 * OpenAPI spec version: 0.5.6-PRIVATE
 * Contact: juancromero@grupotecopy.es
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { CollectionName } from '../model/collectionName';
import { DataSource } from '../model/dataSource';
import { ServiceResponseError } from '../model/serviceResponseError';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class FuentesDeDatosService {

    protected basePath = '{servidor}/public/{version}';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * ampliar informacion
     * @param collection collection
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public datasourceCollectionsfieldsCollectionGet(collection: string, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: string; }>;
    public datasourceCollectionsfieldsCollectionGet(collection: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: string; }>>;
    public datasourceCollectionsfieldsCollectionGet(collection: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: string; }>>;
    public datasourceCollectionsfieldsCollectionGet(collection: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling datasourceCollectionsfieldsCollectionGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<{ [key: string]: string; }>('get',`${this.basePath}/datasource/collectionsfields/${encodeURIComponent(String(collection))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Elimina una fuente de datos
     * @param dataSourceId datasourceId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public datasourceDataSourceIdDelete(dataSourceId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public datasourceDataSourceIdDelete(dataSourceId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public datasourceDataSourceIdDelete(dataSourceId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public datasourceDataSourceIdDelete(dataSourceId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceId === null || dataSourceId === undefined) {
            throw new Error('Required parameter dataSourceId was null or undefined when calling datasourceDataSourceIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/datasource/${encodeURIComponent(String(dataSourceId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * obtiene una fuente de datos mediante su id
     * @param dataSourceId datasourceId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public datasourceDataSourceIdGet(dataSourceId: string, observe?: 'body', reportProgress?: boolean): Observable<DataSource>;
    public datasourceDataSourceIdGet(dataSourceId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DataSource>>;
    public datasourceDataSourceIdGet(dataSourceId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DataSource>>;
    public datasourceDataSourceIdGet(dataSourceId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceId === null || dataSourceId === undefined) {
            throw new Error('Required parameter dataSourceId was null or undefined when calling datasourceDataSourceIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<DataSource>('get',`${this.basePath}/datasource/${encodeURIComponent(String(dataSourceId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Actualiza una fuente de datos
     * 
     * @param body dataSource
     * @param dataSourceId datasourceId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public datasourceDataSourceIdPut(body: DataSource, dataSourceId: string, observe?: 'body', reportProgress?: boolean): Observable<DataSource>;
    public datasourceDataSourceIdPut(body: DataSource, dataSourceId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DataSource>>;
    public datasourceDataSourceIdPut(body: DataSource, dataSourceId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DataSource>>;
    public datasourceDataSourceIdPut(body: DataSource, dataSourceId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling datasourceDataSourceIdPut.');
        }

        if (dataSourceId === null || dataSourceId === undefined) {
            throw new Error('Required parameter dataSourceId was null or undefined when calling datasourceDataSourceIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DataSource>('put',`${this.basePath}/datasource/${encodeURIComponent(String(dataSourceId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * En CRM se podrá definir una fuente de datos que permita seleccionar datos de una colección y definir un metodo de agregación
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public datasourceGet(observe?: 'body', reportProgress?: boolean): Observable<Array<DataSource>>;
    public datasourceGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DataSource>>>;
    public datasourceGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DataSource>>>;
    public datasourceGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<DataSource>>('get',`${this.basePath}/datasource`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body dataSource
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public datasourcePost(body: DataSource, observe?: 'body', reportProgress?: boolean): Observable<DataSource>;
    public datasourcePost(body: DataSource, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DataSource>>;
    public datasourcePost(body: DataSource, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DataSource>>;
    public datasourcePost(body: DataSource, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling datasourcePost.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DataSource>('post',`${this.basePath}/datasource`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Ejecuta una fuente de datos por su Id
     * 
     * @param datasourceId id de la fuente de datos
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public datasourceRunDatasourceIdPost(datasourceId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public datasourceRunDatasourceIdPost(datasourceId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public datasourceRunDatasourceIdPost(datasourceId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public datasourceRunDatasourceIdPost(datasourceId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (datasourceId === null || datasourceId === undefined) {
            throw new Error('Required parameter datasourceId was null or undefined when calling datasourceRunDatasourceIdPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<any>>('post',`${this.basePath}/datasource/run/${encodeURIComponent(String(datasourceId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Ejecuta y devuelve los datos de una fuente de datos
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public datasourceRunPost(body?: DataSource, observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public datasourceRunPost(body?: DataSource, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public datasourceRunPost(body?: DataSource, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public datasourceRunPost(body?: DataSource, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Array<any>>('post',`${this.basePath}/datasource/run`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getCollectionsNames
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCollectionsNamesUsingGET(observe?: 'body', reportProgress?: boolean): Observable<Array<CollectionName>>;
    public getCollectionsNamesUsingGET(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CollectionName>>>;
    public getCollectionsNamesUsingGET(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CollectionName>>>;
    public getCollectionsNamesUsingGET(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<CollectionName>>('get',`${this.basePath}/datasource/collectionsnames`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
