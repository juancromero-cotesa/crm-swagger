/**
 * Api CRM
 * Especificaciónes de la API pública de CRM.  # Versión 2 parte pública.  ***  Los métodos estaran protegidos mediante el paso de un token válido.  Los métodos que puedan ser accedidos por aplicaciones de terceros estarán protegidos por el paso de una api key que tendrá definidos los permisos correspondientes.  Se eliminan las descriciones de cambios de versiones anteriores a la 5, se pueden consultar en las versiones previas    ### 0.5.0 ***  ###Contacto Campaña Se define el esquema CampaignContact Se añaden los métodos para la obtención, creación y borrado masivo de contactos en una campaña Se añaden los métodos para la obtención, edición y borrado de contactos , de manera individual, en una campaña  ###CitizenCard Se añade la propiedad citizenId en tarjeta ciudadana   ### 0.5.1 *** Se declara el esquema Survey que almacenará valoraciones del ciudadano  ###Solicitudes Se depreca   /crmrequests/{crmRequestId}/bpsprocess Añade el método POST   /crmrequests/{crmRequestId}/survey para almacenar la respuesta a la valoración de la solicitud Se añade la propiedad survey a la solicitud para almacenar la valoración del ciudadano a la atención recibida Se modifica el método en el método /crmrequests/{crmRequestId}/situation la clase del objeto a enviar en el post de CrmRequest a Situation  ###Person Se añade la propiedad surveys para almacenar las valoraciones del ciudadano al servicio prestado por el ayuntamiento Añade el método POST   /persons/survey para almacenar una nueva respuesta de encuesta de valoración del servicio  ###0.5.2 ***  ###Personas   se modifica el método /persons/survey/ a   /persons/survey/{personId} pasando el id de la persona a la que establecer la encuesta    ##0.5.3 ***  ### Auth Se define el método auth/thirdpartylogin para proporcionar login SSO a terceros (ya implementado)  ### Comment Se agregan los campos tipo, codigo y descripcion de la situacion a los comentarios de una solicitud y una interaccion  ##0.5.4 ***  ### Tipos de interacciones  Define la propiedad identificator en el esquema de tipo de interacción Define el método  /interactions/types/{identificator} para obtener un tipo de interacción por su identificador 
 *
 * OpenAPI spec version: 0.5.4-PRIVATE
 * Contact: juancromero@grupotecopy.es
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AnyValue } from '../model/anyValue';
import { Integration } from '../model/integration';
import { ServiceResponseError } from '../model/serviceResponseError';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class IntegracionesService {

    protected basePath = '{servidor}/public/{version}';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Obtiene el catálogo de integraciones
     * Obtiene todas las integraciones sin paginar
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public integrationsGet(observe?: 'body', reportProgress?: boolean): Observable<Array<Integration>>;
    public integrationsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Integration>>>;
    public integrationsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Integration>>>;
    public integrationsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<Integration>>('get',`${this.basePath}/integrations`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Elimina todos los datos de una  integración
     * Elimina los datos de una integración realizada
     * @param integrationId nombre de la integración (id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public integrationsIntegrationIdDataDelete(integrationId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public integrationsIntegrationIdDataDelete(integrationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public integrationsIntegrationIdDataDelete(integrationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public integrationsIntegrationIdDataDelete(integrationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (integrationId === null || integrationId === undefined) {
            throw new Error('Required parameter integrationId was null or undefined when calling integrationsIntegrationIdDataDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/integrations/${encodeURIComponent(String(integrationId))}/data`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene los datos de una integración
     * Obtiene los todos los datos de una integración externa por su id
     * @param integrationId nombre de la integración (id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public integrationsIntegrationIdDataGet(integrationId: string, observe?: 'body', reportProgress?: boolean): Observable<AnyValue>;
    public integrationsIntegrationIdDataGet(integrationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AnyValue>>;
    public integrationsIntegrationIdDataGet(integrationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AnyValue>>;
    public integrationsIntegrationIdDataGet(integrationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (integrationId === null || integrationId === undefined) {
            throw new Error('Required parameter integrationId was null or undefined when calling integrationsIntegrationIdDataGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AnyValue>('get',`${this.basePath}/integrations/${encodeURIComponent(String(integrationId))}/data`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Carga datos de de una integración
     * Realiza una carga de datos de integración *** Por defecto inserta todos los registros, este comportamiento se puede cambiar con el parámetro mode.  Deberá realizar las siguientes comprobaciones en los datos a importar - Llega en el atributo integrationName con el nombre de la integración y esta existe - Llegan los valores definidos en la integración comoperson claves (key)  Para cada registro de importación deberá anotar a cada persona en su propiedad integrations que es un array - El nombre de la importación - la fecha de importación  Para acceder a la persona se usará la relación definida en la integración 
     * @param body 
     * @param mode Modo de carga de los datos de integración, pueden ser - reset - Elimina el contenido actual y carga el nuevo - upsert - Inserta o actualiza los datos por la clave especificada - insert - Inserta todo el contenido 
     * @param integrationId nombre de la integración (id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public integrationsIntegrationIdDataPost(body: AnyValue, mode: string, integrationId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public integrationsIntegrationIdDataPost(body: AnyValue, mode: string, integrationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public integrationsIntegrationIdDataPost(body: AnyValue, mode: string, integrationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public integrationsIntegrationIdDataPost(body: AnyValue, mode: string, integrationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling integrationsIntegrationIdDataPost.');
        }

        if (mode === null || mode === undefined) {
            throw new Error('Required parameter mode was null or undefined when calling integrationsIntegrationIdDataPost.');
        }

        if (integrationId === null || integrationId === undefined) {
            throw new Error('Required parameter integrationId was null or undefined when calling integrationsIntegrationIdDataPost.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (mode !== undefined && mode !== null) {
            queryParameters = queryParameters.set('mode', <any>mode);
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/integrations/${encodeURIComponent(String(integrationId))}/data`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Elimina integración
     * Elimina una configuración de integración
     * @param integrationId nombre de la integración (id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public integrationsIntegrationIdDelete(integrationId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public integrationsIntegrationIdDelete(integrationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public integrationsIntegrationIdDelete(integrationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public integrationsIntegrationIdDelete(integrationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (integrationId === null || integrationId === undefined) {
            throw new Error('Required parameter integrationId was null or undefined when calling integrationsIntegrationIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/integrations/${encodeURIComponent(String(integrationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene una integración
     * Obtiene una integración externa por su id
     * @param integrationId nombre de la integración (id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public integrationsIntegrationIdGet(integrationId: string, observe?: 'body', reportProgress?: boolean): Observable<Integration>;
    public integrationsIntegrationIdGet(integrationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Integration>>;
    public integrationsIntegrationIdGet(integrationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Integration>>;
    public integrationsIntegrationIdGet(integrationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (integrationId === null || integrationId === undefined) {
            throw new Error('Required parameter integrationId was null or undefined when calling integrationsIntegrationIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Integration>('get',`${this.basePath}/integrations/${encodeURIComponent(String(integrationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Actualiza integración
     * Actualiza una configuración de integración
     * @param body 
     * @param integrationId nombre de la integración (id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public integrationsIntegrationIdPut(body: Integration, integrationId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public integrationsIntegrationIdPut(body: Integration, integrationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public integrationsIntegrationIdPut(body: Integration, integrationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public integrationsIntegrationIdPut(body: Integration, integrationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling integrationsIntegrationIdPut.');
        }

        if (integrationId === null || integrationId === undefined) {
            throw new Error('Required parameter integrationId was null or undefined when calling integrationsIntegrationIdPut.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/integrations/${encodeURIComponent(String(integrationId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Nueva configuración de integración
     * Crea una nueva configuración de integración
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public integrationsPost(body: Integration, observe?: 'body', reportProgress?: boolean): Observable<Integration>;
    public integrationsPost(body: Integration, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Integration>>;
    public integrationsPost(body: Integration, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Integration>>;
    public integrationsPost(body: Integration, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling integrationsPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (BearerToken) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Integration>('post',`${this.basePath}/integrations`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
